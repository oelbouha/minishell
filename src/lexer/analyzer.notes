|:
	first token: syntax error near unexpected token `|'
	after '|'  : syntax error near unexpected token `|'
	after '('  : syntax error near unexpected token `|'
	after '&&' : syntax error near unexpected token `|'
	after '||' : syntax error near unexpected token `|'
	after >/<  : syntax error near unexpected token `|'
	last token : syntax error: unexpected end of file
(:
	after ')'  : syntax error near unexpected token `('
	after word : syntax error near unexpected token `(' # bash would expect a fucntion
	after >/<  : syntax error near unexpected token `|'
	last token : syntax error: unexpected end of file
):
	first token: syntax error near unexpected token `)'
	after '|'  : syntax error near unexpected token `)'
	after '('  : syntax error near unexpected token `)'
	after '&&' : syntax error near unexpected token `)'
	after '||' : syntax error near unexpected token `)'
	after >/<  : syntax error near unexpected token `|'
&&/||:
	first token: syntax error near unexpected token `|'
	after '|'  : syntax error near unexpected token `|'
	after '('  : syntax error near unexpected token `|'
	after '&&' : syntax error near unexpected token `|'
	after '||' : syntax error near unexpected token `|'
	after >/<  : syntax error near unexpected token `|'
	last token : syntax error: unexpected end of file
word:
	after ')'  : syntax error near unexpected token `word'
>/<:	
	after >/<  : syntax error near unexpected token `|'
	last token : syntax error: unexpected end of file





/*

// line full of spaces  [node->content = NULL]
// failed allocation	[NULL]

t_list *token;
loop(*line)
{
	token = get_token(line); // if null error
	if (token == NULL)
		return (ft_lstclear(&list), NULL);
	else if (token->content == NULL)
		//
	if (analyze_syntax(list, token->content))
		msh_error("msg");
	lstadd_back();
	line += ft_strlen(token->content);
}
if (analyze_syntax(list, NULL))
	//

int	analyze_syntax(char *last, char *token)
{
	int	err;

	err = 0;
	err += check_pipe(last, token);
	err += check_opened_parentheses(last, token);
	err += check_closeded_parentheses(last, token);
	err += check_and_nd_or(last, token);
	err += check_redirections(last, token);
	err += check_word(last, token);
}

check_word(char *last, char *token)
{
	if (token == NULL)
		return (1);
	else if (last == NULL)
		return (0);
	return (ft_strcmp(last, ")") == 0)
}

check_pipe(char *last, char *token)
{
	if (last == token == NULL)
		return (1);
	if (ft_strcmp(last, "|") == 0 || ft_strcmp(token, "|") == 0)
	{
		if (token == null || last == null)
			return 1;
		else if (ft_strcmp(token, "|"))
			return 0;
		return (cmp(last,"|:(:&&:||:>:>>:<<:<"));
	}
	return (0);
}

cmp(char *str, char *template)
{
	int	i = 0;
	int	len = ft_strlen(str);
	while (template[i])
	{
		if (ft_strncmp(str, &template[i]) == 0)
			if (template[i + len] == ':')
				return (1);
		while (template[i] && template[i] != ':')
			i++;
		i++;
	}
	return (0);
}

loop
{
	list = lexer(&err);
	tree = parse(list);
	if (err == 0)
		execute(tree);
	free(tree)
}


*/