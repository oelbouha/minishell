export n=5 | echo $n
cmd1:
	"export" "n=5"
cmd2:
	"echo" ""


(cd /)
(export n=5 && echo $n) && ()
box:
	cmd1:
		"export" "n=5"
	cmd2:
		"echo" "$n"

{
	reader => line;
	lexer
	parser
	{
		(expansion);
		if (excutor)
			return (get_last_status());
	}

}



(ls && (echo hello && cat < file) >out) >> out2 | (cd / && ls || echo err) | echo last
[
	prev: "("
	[
		prev: NULL
		ls
	],
	[
		prev: "&&"
		prev: "("
		[
			echo hello
		]
		[
			prev: "&&"
			cat
			< file
		]
		>> out
	]
	>> out2
]
[
	prev: "|"
	prev: "("
	[
		cd /
	]
	[
		prev: "&&"
		ls
	]
	[
		prev: '||'
		echo err
	]
]
[
	prev: "|"
	echo last
]




[   >> out2 ]

[cmd1, cmd2, cmd3] 	pipes
cmd1->cmd2->cmd3	&& and ||


lsfd && echof hello | echo hello

[ls]->&&[echof hello, echo hello]

lsfd || echof hello | echo hello > file | skldjfkls  && echo hi

[lsfd]->(or)[echof hello, echo hello > file, skldjfkls]->(and)[echo hi]

>file > file

sp: " ' ( && || > >> < <<

(sdfsdf) => "(" "sdsfdf" ")"
"word word0" => """, "word word0"
'word word0' => "'", "word word0"

<>file
< >file

[]
line[i] == '|' && line[i + 1] 

loop <c>{
	if (c == '(' && parenthesis_handler)//SHOULD_HANDLE_PARENTHESIS
		i+=parenthesis_handler(lst, &c, &err); // should be recursive.  int	func(t_list **head, char *str, int *err)
	else if (c == '||' && and_or_handler)
	{
		lst->["||/&&"]
		i += 2;
	}
	else if (c == '"')
		i += double_quote_handler()
	else if (c == '>' || c == '<')
	{
		if (str[i] == '<' && str[i+1] == '>')//<<
		{
			lst->["<<"]
			i+=2;
		}
		else if (str[i-1] == '>' && str[i] == '>')//>>
		{
			lst->[">>"]
			i+=2;
		}
		else
			lst->[str[i++]]
	}
	else if (c == ' ' || c == '\t')
		i++;
	else
		i+=handle_normal_word(lst, c, &err)
	if (err)
		//clean and return (NULL);

}

token = dup_len(&str[i],len)
node = ft_lstnew(token)
lstadd_back

(ls && (lksdjfklsdflkjsdf ) | echhks)

lst->["("]
lst->["ls"]
lst->["&&"]
	i+=call
	lst->["("]
	lst->["lskdfjlksfjklsfj"]
	lst->[")"]
	return i + 1;
lst->["|"]

